package gen

// Code generated by github.com/pfcm/ktf/cmd/gen from kubernetes_network_policy,
// schema version 0
// DO NOT EDIT.

import (
	"fmt"

	"github.com/zclconf/go-cty/cty"
)

// Make sure resources with no list attributes don't cause build errors because
// of an unused import.
var _ = fmt.Sprintf

func init() {
	register("kubernetes_network_policy", kubernetesNetworkPolicy)
}

var kubernetesNetworkPolicy = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes:   map[string]func(any) (cty.Value, error){},
	Blocks: map[string]ConverterSpec{
		"metadata": kubernetesNetworkPolicy_metadata,
		"spec":     kubernetesNetworkPolicy_spec,
	},
}

var kubernetesNetworkPolicy_spec = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"policy_types": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{
		"egress":       kubernetesNetworkPolicy_spec_egress,
		"ingress":      kubernetesNetworkPolicy_spec_ingress,
		"pod_selector": kubernetesNetworkPolicy_spec_podSelector,
	},
}

var kubernetesNetworkPolicy_spec_podSelector = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"match_labels": toStringMap,
	},
	Blocks: map[string]ConverterSpec{
		"match_expressions": kubernetesNetworkPolicy_spec_podSelector_matchExpressions,
	},
}

var kubernetesNetworkPolicy_spec_podSelector_matchExpressions = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"key":      toString,
		"operator": toString,
		"values": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesNetworkPolicy_spec_egress = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes:   map[string]func(any) (cty.Value, error){},
	Blocks: map[string]ConverterSpec{
		"ports": kubernetesNetworkPolicy_spec_egress_ports,
		"to":    kubernetesNetworkPolicy_spec_egress_to,
	},
}

var kubernetesNetworkPolicy_spec_egress_to = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes:   map[string]func(any) (cty.Value, error){},
	Blocks: map[string]ConverterSpec{
		"ip_block":           kubernetesNetworkPolicy_spec_egress_to_ipBlock,
		"namespace_selector": kubernetesNetworkPolicy_spec_egress_to_namespaceSelector,
		"pod_selector":       kubernetesNetworkPolicy_spec_egress_to_podSelector,
	},
}

var kubernetesNetworkPolicy_spec_egress_to_namespaceSelector = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"match_labels": toStringMap,
	},
	Blocks: map[string]ConverterSpec{
		"match_expressions": kubernetesNetworkPolicy_spec_egress_to_namespaceSelector_matchExpressions,
	},
}

var kubernetesNetworkPolicy_spec_egress_to_namespaceSelector_matchExpressions = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"key":      toString,
		"operator": toString,
		"values": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesNetworkPolicy_spec_egress_to_ipBlock = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"cidr": toString,
		"except": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesNetworkPolicy_spec_egress_to_podSelector = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"match_labels": toStringMap,
	},
	Blocks: map[string]ConverterSpec{
		"match_expressions": kubernetesNetworkPolicy_spec_egress_to_podSelector_matchExpressions,
	},
}

var kubernetesNetworkPolicy_spec_egress_to_podSelector_matchExpressions = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"key":      toString,
		"operator": toString,
		"values": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesNetworkPolicy_spec_egress_ports = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"end_port": toInt,
		"port":     toString,
		"protocol": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesNetworkPolicy_spec_ingress = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes:   map[string]func(any) (cty.Value, error){},
	Blocks: map[string]ConverterSpec{
		"from":  kubernetesNetworkPolicy_spec_ingress_from,
		"ports": kubernetesNetworkPolicy_spec_ingress_ports,
	},
}

var kubernetesNetworkPolicy_spec_ingress_from = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes:   map[string]func(any) (cty.Value, error){},
	Blocks: map[string]ConverterSpec{
		"ip_block":           kubernetesNetworkPolicy_spec_ingress_from_ipBlock,
		"namespace_selector": kubernetesNetworkPolicy_spec_ingress_from_namespaceSelector,
		"pod_selector":       kubernetesNetworkPolicy_spec_ingress_from_podSelector,
	},
}

var kubernetesNetworkPolicy_spec_ingress_from_podSelector = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"match_labels": toStringMap,
	},
	Blocks: map[string]ConverterSpec{
		"match_expressions": kubernetesNetworkPolicy_spec_ingress_from_podSelector_matchExpressions,
	},
}

var kubernetesNetworkPolicy_spec_ingress_from_podSelector_matchExpressions = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"key":      toString,
		"operator": toString,
		"values": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesNetworkPolicy_spec_ingress_from_namespaceSelector = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"match_labels": toStringMap,
	},
	Blocks: map[string]ConverterSpec{
		"match_expressions": kubernetesNetworkPolicy_spec_ingress_from_namespaceSelector_matchExpressions,
	},
}

var kubernetesNetworkPolicy_spec_ingress_from_namespaceSelector_matchExpressions = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"key":      toString,
		"operator": toString,
		"values": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesNetworkPolicy_spec_ingress_from_ipBlock = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"cidr": toString,
		"except": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesNetworkPolicy_spec_ingress_ports = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"end_port": toInt,
		"port":     toString,
		"protocol": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesNetworkPolicy_metadata = ConverterSpec{
	ResourceName: "kubernetes_network_policy",
	Attributes: map[string]func(any) (cty.Value, error){
		"annotations":   toStringMap,
		"generate_name": toString,
		"labels":        toStringMap,
		"name":          toString,
		"namespace":     toString,
	},
	Blocks: map[string]ConverterSpec{},
}
