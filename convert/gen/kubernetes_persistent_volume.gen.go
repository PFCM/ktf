package gen

// Code generated by github.com/pfcm/ktf/cmd/gen from kubernetes_persistent_volume,
// schema version 0
// DO NOT EDIT.

import (
	"fmt"

	"github.com/zclconf/go-cty/cty"
)

// Make sure resources with no list attributes don't cause build errors because
// of an unused import.
var _ = fmt.Sprintf

func init() {
	register("kubernetes_persistent_volume", kubernetesPersistentVolume)
}

var kubernetesPersistentVolume = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes:   map[string]func(any) (cty.Value, error){},
	Blocks: map[string]ConverterSpec{
		"metadata": kubernetesPersistentVolume_metadata,
		"spec":     kubernetesPersistentVolume_spec,
	},
}

var kubernetesPersistentVolume_spec = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"access_modes": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
		"capacity": toStringMap,
		"mount_options": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
		"persistent_volume_reclaim_policy": toString,
		"storage_class_name":               toString,
		"volume_mode":                      toString,
	},
	Blocks: map[string]ConverterSpec{
		"claim_ref":                kubernetesPersistentVolume_spec_claimRef,
		"node_affinity":            kubernetesPersistentVolume_spec_nodeAffinity,
		"persistent_volume_source": kubernetesPersistentVolume_spec_persistentVolumeSource,
	},
}

var kubernetesPersistentVolume_spec_nodeAffinity = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes:   map[string]func(any) (cty.Value, error){},
	Blocks: map[string]ConverterSpec{
		"required": kubernetesPersistentVolume_spec_nodeAffinity_required,
	},
}

var kubernetesPersistentVolume_spec_nodeAffinity_required = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes:   map[string]func(any) (cty.Value, error){},
	Blocks: map[string]ConverterSpec{
		"node_selector_term": kubernetesPersistentVolume_spec_nodeAffinity_required_nodeSelectorTerm,
	},
}

var kubernetesPersistentVolume_spec_nodeAffinity_required_nodeSelectorTerm = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes:   map[string]func(any) (cty.Value, error){},
	Blocks: map[string]ConverterSpec{
		"match_expressions": kubernetesPersistentVolume_spec_nodeAffinity_required_nodeSelectorTerm_matchExpressions,
		"match_fields":      kubernetesPersistentVolume_spec_nodeAffinity_required_nodeSelectorTerm_matchFields,
	},
}

var kubernetesPersistentVolume_spec_nodeAffinity_required_nodeSelectorTerm_matchFields = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"key":      toString,
		"operator": toString,
		"values": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_nodeAffinity_required_nodeSelectorTerm_matchExpressions = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"key":      toString,
		"operator": toString,
		"values": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes:   map[string]func(any) (cty.Value, error){},
	Blocks: map[string]ConverterSpec{
		"aws_elastic_block_store": kubernetesPersistentVolume_spec_persistentVolumeSource_awsElasticBlockStore,
		"azure_disk":              kubernetesPersistentVolume_spec_persistentVolumeSource_azureDisk,
		"azure_file":              kubernetesPersistentVolume_spec_persistentVolumeSource_azureFile,
		"ceph_fs":                 kubernetesPersistentVolume_spec_persistentVolumeSource_cephFs,
		"cinder":                  kubernetesPersistentVolume_spec_persistentVolumeSource_cinder,
		"csi":                     kubernetesPersistentVolume_spec_persistentVolumeSource_csi,
		"fc":                      kubernetesPersistentVolume_spec_persistentVolumeSource_fc,
		"flex_volume":             kubernetesPersistentVolume_spec_persistentVolumeSource_flexVolume,
		"flocker":                 kubernetesPersistentVolume_spec_persistentVolumeSource_flocker,
		"gce_persistent_disk":     kubernetesPersistentVolume_spec_persistentVolumeSource_gcePersistentDisk,
		"glusterfs":               kubernetesPersistentVolume_spec_persistentVolumeSource_glusterfs,
		"host_path":               kubernetesPersistentVolume_spec_persistentVolumeSource_hostPath,
		"iscsi":                   kubernetesPersistentVolume_spec_persistentVolumeSource_iscsi,
		"local":                   kubernetesPersistentVolume_spec_persistentVolumeSource_local,
		"nfs":                     kubernetesPersistentVolume_spec_persistentVolumeSource_nfs,
		"photon_persistent_disk":  kubernetesPersistentVolume_spec_persistentVolumeSource_photonPersistentDisk,
		"quobyte":                 kubernetesPersistentVolume_spec_persistentVolumeSource_quobyte,
		"rbd":                     kubernetesPersistentVolume_spec_persistentVolumeSource_rbd,
		"vsphere_volume":          kubernetesPersistentVolume_spec_persistentVolumeSource_vsphereVolume,
	},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_rbd = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"ceph_monitors": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
		"fs_type":    toString,
		"keyring":    toString,
		"rados_user": toString,
		"rbd_image":  toString,
		"rbd_pool":   toString,
		"read_only":  toBool,
	},
	Blocks: map[string]ConverterSpec{
		"secret_ref": kubernetesPersistentVolume_spec_persistentVolumeSource_rbd_secretRef,
	},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_rbd_secretRef = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"name":      toString,
		"namespace": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_csi = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"driver":            toString,
		"fs_type":           toString,
		"read_only":         toBool,
		"volume_attributes": toStringMap,
		"volume_handle":     toString,
	},
	Blocks: map[string]ConverterSpec{
		"controller_expand_secret_ref":  kubernetesPersistentVolume_spec_persistentVolumeSource_csi_controllerExpandSecretRef,
		"controller_publish_secret_ref": kubernetesPersistentVolume_spec_persistentVolumeSource_csi_controllerPublishSecretRef,
		"node_publish_secret_ref":       kubernetesPersistentVolume_spec_persistentVolumeSource_csi_nodePublishSecretRef,
		"node_stage_secret_ref":         kubernetesPersistentVolume_spec_persistentVolumeSource_csi_nodeStageSecretRef,
	},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_csi_controllerExpandSecretRef = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"name":      toString,
		"namespace": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_csi_controllerPublishSecretRef = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"name":      toString,
		"namespace": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_csi_nodePublishSecretRef = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"name":      toString,
		"namespace": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_csi_nodeStageSecretRef = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"name":      toString,
		"namespace": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_vsphereVolume = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"fs_type":     toString,
		"volume_path": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_gcePersistentDisk = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"fs_type":   toString,
		"partition": toInt,
		"pd_name":   toString,
		"read_only": toBool,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_cinder = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"fs_type":   toString,
		"read_only": toBool,
		"volume_id": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_photonPersistentDisk = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"fs_type": toString,
		"pd_id":   toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_glusterfs = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"endpoints_name": toString,
		"path":           toString,
		"read_only":      toBool,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_azureDisk = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"caching_mode":  toString,
		"data_disk_uri": toString,
		"disk_name":     toString,
		"fs_type":       toString,
		"kind":          toString,
		"read_only":     toBool,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_awsElasticBlockStore = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"fs_type":   toString,
		"partition": toInt,
		"read_only": toBool,
		"volume_id": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_local = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"path": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_hostPath = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"path": toString,
		"type": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_quobyte = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"group":     toString,
		"read_only": toBool,
		"registry":  toString,
		"user":      toString,
		"volume":    toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_nfs = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"path":      toString,
		"read_only": toBool,
		"server":    toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_iscsi = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"fs_type":         toString,
		"iqn":             toString,
		"iscsi_interface": toString,
		"lun":             toInt,
		"read_only":       toBool,
		"target_portal":   toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_flocker = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"dataset_name": toString,
		"dataset_uuid": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_flexVolume = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"driver":    toString,
		"fs_type":   toString,
		"options":   toStringMap,
		"read_only": toBool,
	},
	Blocks: map[string]ConverterSpec{
		"secret_ref": kubernetesPersistentVolume_spec_persistentVolumeSource_flexVolume_secretRef,
	},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_flexVolume_secretRef = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"name":      toString,
		"namespace": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_fc = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"fs_type":   toString,
		"lun":       toInt,
		"read_only": toBool,
		"target_ww_ns": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_cephFs = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"monitors": func(a any) (cty.Value, error) {
			l, ok := a.([]any)
			if !ok {
				return cty.Value{}, fmt.Errorf("expected slice, got: %T", a)
			}
			vl := make([]cty.Value, 0, len(l))
			for _, val := range l {
				v, err := toString(val)
				if err != nil {
					return cty.Value{}, err
				}
				vl = append(vl, v)
			}
			return cty.ListVal(vl), nil
		},
		"path":        toString,
		"read_only":   toBool,
		"secret_file": toString,
		"user":        toString,
	},
	Blocks: map[string]ConverterSpec{
		"secret_ref": kubernetesPersistentVolume_spec_persistentVolumeSource_cephFs_secretRef,
	},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_cephFs_secretRef = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"name":      toString,
		"namespace": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_persistentVolumeSource_azureFile = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"read_only":        toBool,
		"secret_name":      toString,
		"secret_namespace": toString,
		"share_name":       toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_spec_claimRef = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"name":      toString,
		"namespace": toString,
	},
	Blocks: map[string]ConverterSpec{},
}

var kubernetesPersistentVolume_metadata = ConverterSpec{
	ResourceName: "kubernetes_persistent_volume",
	Attributes: map[string]func(any) (cty.Value, error){
		"annotations": toStringMap,
		"labels":      toStringMap,
		"name":        toString,
	},
	Blocks: map[string]ConverterSpec{},
}
